#!/usr/bin/env python3

VERSION = 1.0
DEFAULT_SUBPADS_HEIGHT = 32767
DEFAULT_SUBPADS_SHOWN_HEIGHT = 4
HEADER_LINES = 2

import sys
import os
from datetime import datetime
import argparse
import logging
import threading
import subprocess
import curses
import traceback

class Logger:
	def __init__(self):
		logging.basicConfig(level = logging.INFO, format = '%(asctime)s \033[1;32m[%(tag)s]\033[0m %(message)s')
		self._logger = logging.getLogger('MAIN')
		self._logger.setLevel(logging.INFO)

	def log(self, tag, message):
		if message.endswith('\n'):	message = message[:-1]
		for line in message.split('\n'):
			self._logger.info(line, extra={'tag': tag})

class FileLogger:
	def __init__(self, lvl = 0):
		if not os.path.isdir('.para-run/'):
			os.mkdir('.para-run/', mode=0o755)
		self._fl = open('.para-run/run.log', 'a')
		self._fl.write('\n')
		self._fl.flush()
		self.mutex = threading.Lock()
		self.lvl = lvl
	
	def log(self, tag, message, lvl = 0):
		self.mutex.acquire()
		if not self._fl or lvl > self.lvl:
			self.mutex.release()
			return
		for line in message.split('\n'):
			self._fl.write('%s %d [%s] %s\n' % (str(datetime.now()), lvl, tag, line))
			self._fl.flush()
		self.mutex.release()
	
	def __del__(self):
		self.mutex.acquire()
		self._fl.close()
		self._fl = None
		self.mutex.release()

class WindowHandler:
	class SubPad:
		def __init__(self, wh, index):
			self.wh = wh
			self.index = index
			self.shown_height = wh.subpads_shown_height
			self.watching_at_end = True
			self.visible_pos = 0
			# Allow a separation line between tasks
			self.shown_pos_offset = index * (wh.subpads_shown_height + 1) + HEADER_LINES
			self.pad = curses.newpad(DEFAULT_SUBPADS_HEIGHT, wh.width)
			self.pad.scrollok(True)
			self._swap_buffer(wh.output_buffer[index])

		def _swap_buffer(self, buffered_lines):
			self.pad.addstr(buffered_lines)
			self._refresh(self.watching_at_end)
			self.wh.stdscr.refresh()

		def _refresh(self, force_watching_at_end=False):
			assert(self.wh.mutex.locked())
			if force_watching_at_end:
				self.watching_at_end = True

			# pad area: pad_render_offset_start ~ pad_render_offset_end
			# window area: 2 ~ self.wh.height
			pad_render_offset_start = self.shown_pos_offset + self.wh.user_control_offset + 1
			pad_render_offset_end = pad_render_offset_start + self.shown_height - 1
			render_offset_start = max(pad_render_offset_start, HEADER_LINES)
			render_offset_end = min(pad_render_offset_end, self.wh.height - 1)
			if render_offset_start >= self.wh.height \
			or render_offset_end < HEADER_LINES:
				return

			render_height = render_offset_end - render_offset_start + 1

			y, x = self.pad.getyx()
			if self.watching_at_end:
				self.visible_pos = max(max(y, self.shown_height) - render_height, 0)
				#self.visible_pos = max(y - render_height + 1, 0)

			# +2 is magic number, haha
			# This is because we reserve a line at the bottom
			self.pad.refresh(self.visible_pos, 0,
					render_offset_start, 0,
					render_offset_end, self.wh.width)

			self.wh.gfl.log('SubPad(%d)' % self.index,
					'refresh ' + repr(self) + f' region w={self.wh.width},h={self.wh.height},rs={render_offset_start},re={render_offset_end}', 3)
			#traceback.print_stack(file=self.wh.gfl._fl)

			# pad subtitle
			pad_title_pos = self.shown_pos_offset + self.wh.user_control_offset
			if HEADER_LINES <= pad_title_pos < self.wh.height:
				if self.wh.color_available:
					#title = '[PROC %d] %s' % (self.index+1, self.wh.cmds[self.index])
					title = '[PROC %d] (%s) %s' % (self.index+1,
							(self.wh.tasks_running_status[self.index] \
								and 'RUNNING' or 'STOPPED'),
							self.wh.cmds[self.index])
						
					self.wh.gfl.log('SubPad(%d)' % self.index, 'refresh pad_title_pos ' + str(pad_title_pos) + title, 5)
					self.wh.stdscr.addstr(pad_title_pos, 0, title,
							curses.color_pair(self.wh.tasks_running_status[self.index] and 2 or 3))
				else:
					title = '[PROC %d] (%s) %s' % (self.index+1,
							(self.wh.tasks_running_status[self.index] \
								and 'RUNNING' or 'STOPPED'),
							self.wh.cmds[self.index])
					self.wh.gfl.log('SubPad(%d)' % self.index, 'refresh pad_title_pos ' + str(pad_title_pos) + title, 5)
					self.wh.stdscr.addstr(pad_title_pos, 0, title)

			self.wh.gfl.log('SubPad(%d)' % self.index, 'refresh ' + repr(self) + ' finish.', 5)

		def refresh(self, force_watching_at_end=False):
			self._refresh(force_watching_at_end)

		def __repr__(self):
			y, x = self.pad.getyx()
			return f'WindowHandler.SubPad(h={self.shown_height},v={self.visible_pos},o={self.shown_pos_offset},y={y},x={x})'

	def __init__(self, cmds, gfl):
		self.gfl = gfl
		self.cmds = cmds
		self.tasks_total = len(cmds)
		self.tasks_running_status = [True] * self.tasks_total
		self.output_buffer = [b''] * self.tasks_total
		self.mutex = threading.Lock()
		self.subpads_shown_height = DEFAULT_SUBPADS_SHOWN_HEIGHT
		self.user_control_offset = 0
		self.inited = False

	def append_line(self, task_id, line):
		self.mutex.acquire()
		self.gfl.log('WindowHandler', 'append_line %d %s' % (task_id, str(line)), 2)
		if self.inited:
			if self.output_buffer[task_id - 1]:
				self.output_buffer[task_id - 1] += line
				self.subpads[task_id - 1]._swap_buffer(self.output_buffer[task_id - 1])
			else:
				self.subpads[task_id - 1]._swap_buffer(line)
		else:
			self.output_buffer[task_id - 1] += line
		self.mutex.release()

	def mark_finished(self, task_id):
		self.mutex.acquire()
		self.tasks_running_status[task_id - 1] = False
		self.gfl.log('WindowHandler', 'mark_finished %d' % task_id, 3)
		self._refresh_header()
		self.subpads[task_id - 1].refresh()
		self.stdscr.refresh()
		self.mutex.release()

	def init_size(self):
		self.height, self.width = self.stdscr.getmaxyx()

	# Must be called after curses.initscr()
	def init_all(self, stdscr):
		self.stdscr = stdscr
		self.init_size()
		self.color_available = curses.has_colors()
		if self.color_available:
			curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)
			curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_GREEN)
			curses.init_pair(3, curses.COLOR_WHITE, curses.COLOR_RED)

		self.mutex.acquire()
		self._refresh_header()
		self.subpads = [WindowHandler.SubPad(self, i) for i in range(self.tasks_total)]
		self.inited = True
		self.mutex.release()

	def _refresh_header(self):
		if self.color_available:
			self.stdscr.addstr(0, 0, 'PARA-RUN version %s' % VERSION, curses.color_pair(1))
		else:
			self.stdscr.addstr(0, 0, 'PARA-RUN version %s' % VERSION)
		"""
		for i in range(len(self.subpads)):
			subpad = self.subpads[i]
			show_pos = subpad.shown_pos_offset + self.user_control_offset - 1
			if show_pos < HEADER_LINES:
				continue
			if show_pos >= self.height:
				break
			if self.color_available:
				if self.tasks_running_status[i]:
					self.stdscr.addstr(show_pos, 0, '[PROC %d] (RUNNING)' % (i+1), curses.color_pair(2))
				else:
					self.stdscr.addstr(show_pos, 0, '[PROC %d] (STOPPED)' % (i+1), curses.color_pair(3))
			else:
				if self.tasks_running_status[i]:
					self.stdscr.addstr(show_pos, 0, '[PROC %d] (RUNNING)' % (i+1))
				else:
					self.stdscr.addstr(show_pos, 0, '[PROC %d] (STOPPED)' % (i+1))
		"""

	def refresh_all(self):
		self.mutex.acquire()
		if not self.inited:
			self.mutex.release()
			return
		self.stdscr.clear()
		self._refresh_header()
		for subpad in self.subpads:
			subpad.refresh()
		self.stdscr.refresh()
		self.mutex.release()

	@staticmethod
	def main(stdscr, *args, **kwargs):
		assert(len(args) == 1 and len(kwargs) == 0)
		handler = args[0]

		curses.initscr()
		curses.noecho()
		curses.cbreak()
		stdscr.keypad(True)

		try:
			handler.init_all(stdscr)

			running = True
			while running:
				ch = stdscr.getch()

				render_height_logical_total = HEADER_LINES + \
					sum([(subpad.shown_height+1) for subpad in handler.subpads])

				inferior = (render_height_logical_total > handler.height) \
						and (1 - render_height_logical_total) or 0
				if ch == curses.KEY_DOWN and handler.user_control_offset > inferior:
					handler.user_control_offset -= 1
					handler.gfl.log('CURSES', f'Key DOWN pressed. rhlt={render_height_logical_total} uco={handler.user_control_offset}', 2)
					handler.refresh_all()
				elif ch == curses.KEY_UP and handler.user_control_offset < 0:
					handler.user_control_offset += 1
					handler.gfl.log('CURSES', f'Key UP pressed. rhlt={render_height_logical_total} uco={handler.user_control_offset}', 2)
					handler.refresh_all()
				elif ch == curses.KEY_RESIZE:
					handler.gfl.log('CURSES', f'Window resize. rhlt={render_height_logical_total} uco={handler.user_control_offset}', 2)
					handler.init_size()
					handler.refresh_all()
				elif ch == ord('q'):
					if not True in handler.tasks_running_status:
						running = False
		except KeyboardInterrupt:
			pass

		# Clean up curses
		curses.nocbreak()
		stdscr.keypad(False)
		curses.echo()
		curses.endwin()

def parse_args():
	parser = argparse.ArgumentParser()
	parser.add_argument('cmd', nargs='*', help='Local commands. Wrap long commands with quotes(\"\").')
	parser.add_argument('-r', '--remote-cmds', nargs=2, metavar=('REMOTE_HOSTS', 'CMD'), action='append', help='Target hosts (1-19) are allowed "," and "-", e.g. "1,3-5" is valid. Multiple -r is allowed.')
	parser.add_argument('-d', '--debug-level', type=int, help='Debug level, 0 by default.', default=0)
	args = parser.parse_args()
	if not args.remote_cmds and len(args.cmd) == 0:
		parser.print_help()
		sys.exit(0)
	return args

def trans_cmds(args, logger):
	cmds = list(args.cmd)
	# Remote commands specified?
	if args.remote_cmds:
		illegal_hosts = []
		def trans_remote_cmds(remote_cmd):
			hosts = []
			hosts_str, cmd = remote_cmd
			for host_str in hosts_str.split(','):
				hyphen_pos = host_str.find('-')
				if hyphen_pos == -1:
					try:
						hostid = int(host_str)
						hosts.append(hostid)
					except ValueError:
						illegal_hosts.append(host_str)
						continue
				else:
					hstart = host_str[:hyphen_pos]
					hend = host_str[hyphen_pos + 1:]
					try:
						hstartid = int(hstart)
						hendid = int(hend)
					except ValueError:
						illegal_hosts.append(host_str)
						continue
					hosts += range(hstartid, hendid + 1)

			hosts = list(set(hosts)) # Unique
			#logger.info('\033[1;33mIgnoring hosts: %s\033[0m' % ','.join(illegal_hosts), extra = {'tag': 'MAIN'})
			for hostid in hosts:
				cmds.append('ssh n%d \"%s\"' % (hostid, cmd))

		for remote_cmd in args.remote_cmds:
			trans_remote_cmds(remote_cmd)
		
		if len(illegal_hosts) > 0:
			#logger.log('MAIN', '\033[1;33mIllegal hosts: %s\033[0m' % ','.join(illegal_hosts))
			sys.stderr.write('Illegal hosts: %s\033[0m\n' % ','.join(illegal_hosts))
			sys.exit(-1)

	return cmds

def run_single_cmd(cmd, window_handler, thrd_index):
	if not cmd:	return
	subp = subprocess.Popen(cmd, shell = True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

	for line in iter(subp.stdout.readline, b""):
		window_handler.append_line(thrd_index, line)

	window_handler.mark_finished(thrd_index)

def para_run(cmds, gfl):
	tasks_acc = 1
	tasks_total = len(cmds)
	window_handler = WindowHandler(cmds, gfl)
	thrd_pool = []
	for cmd in cmds:
		t = threading.Thread(target = run_single_cmd, args = (cmd, window_handler, tasks_acc))
		t.start()
		thrd_pool.append(t)
		tasks_acc += 1

	try:
		curses.wrapper(WindowHandler.main, window_handler)
	except Exception as e:
		gfl.log('MAIN', ''.join(traceback.format_exception(None, e, e.__traceback__)))

	for t in thrd_pool:
		t.join()

def main():
	logger = Logger()
	args = parse_args()
	cmds = trans_cmds(args, logger)
	gfl = FileLogger(args.debug_level)

	gfl.log('MAIN', 'para-run (v%s) launch!' % VERSION)

	para_run(cmds, gfl)

	gfl.log('MAIN', 'para-run shutdown successfully.')

	return 0

if __name__ == '__main__':
	sys.exit(main())
